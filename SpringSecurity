## **인증 (Authentication)**

- 인증은 사용자의 신원을 확인하는 과정입니다. 예를 들어, 사용자가 로그인할 때 제공하는 사용자 이름과 비밀번호를 검증하여 해당 사용자가 누구인지를 확인합니다.
- 다양한 인증 방법 지원
    - **폼 로그인(Form Login)**
    - HTTP 기본 인증(Basic Authentication)
    - OAuth2 인증
    - LDAP 인증
    - JWT (JSON Web Token) 인증 등

## **인가 (Authorization)**

- 인가는 인증된 사용자가 특정 리소스나 URL에 접근할 수 있는 권한을 확인하고 제어하는 과정입니다.
- 사용자의 역할(Role)이나 권한(Permission)을 기반으로 접근을 제어합니다. 예를 들어, 관리자만 특정 URL에 접근할 수 있도록 제한하거나, 특정 리소스에 대한 권한을 세밀하게 설정할 수 있습니다.

## **세션 관리**

- 사용자가 로그인 상태를 유지하도록 돕고, 세션을 관리합니다. 예를 들어, **세션 고정 공격(Session Fixation)**을 방지하거나, 세션 타임아웃을 설정할 수 있습니다.

## **보안 헤더 관리**

- HTTP 응답에 보안 관련 헤더를 추가하여 웹 애플리케이션의 보안을 강화합니다. 예를 들어, **X-Content-Type-Options**, **Strict-Transport-Security (HSTS)**, **Content-Security-Policy (CSP)** 등을 설정할 수 있습니다.

## **CSRF (Cross-Site Request Forgery)**

- **CSRF(Cross-Site Request Forgery)**는 악의적인 사용자가 다른 사용자의 세션을 이용해 원하지 않는 요청을 보낼 수 있는 공격입니다. Spring Security는 CSRF 공격을 방지하기 위한 기본적인 보호 기능을 제공합니다.

## **CORS (Cross-Origin Resource Sharing)**

- 서로 다른 출처에서의 HTTP 요청을 처리할 때 발생할 수 있는 보안 문제를 해결하기 위한 설정을 제공합니다.

## **로그인/로그아웃 처리**

- 사용자가 로그인하거나 로그아웃할 때 발생하는 다양한 동작을 처리합니다.
- 예를 들어, **로그인 페이지 커스터마이징**, **로그인 실패 처리**, **자동 로그아웃** 등을 설정할 수 있습니다.

# DelegatingFilterProxy 쉽게 이해하기

## 기본 개념

DelegatingFilterProxy는 Spring에서 제공하는 특별한 필터입니다. 이 필터의 주요 목적은 서블릿 컨테이너와 Spring 애플리케이션 컨텍스트 사이의 다리 역할을 하는 것입니다.

## 왜 필요한가?

1. 서블릿 컨테이너는 자체적으로 필터를 관리합니다.
2. 하지만 Spring의 빈(Bean)에 대해서는 알지 못합니다.
3. DelegatingFilterProxy를 사용하면 Spring의 빈을 서블릿 필터처럼 사용할 수 있습니다.

## 어떻게 작동하는가?

1. DelegatingFilterProxy를 서블릿 필터로 등록합니다.
2. 요청이 들어오면 DelegatingFilterProxy가 먼저 받습니다.
3. 그 다음 Spring 컨텍스트에서 실제 필터 빈을 찾습니다.
4. 찾은 필터 빈에게 실제 작업을 위임합니다.

## 간단한 예시 코드

```java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    if (delegate == null) {
        delegate = findFilterBean("myFilterBean");  // Spring 컨텍스트에서 빈을 찾음
    }
    delegate.doFilter(request, response, chain);  // 실제 필터 작업을 위임
}

// 기타 필요한 메서드들...

```

## 정리

- DelegatingFilterProxy는 "중개자" 역할을 합니다.
- 서블릿 세계와 Spring 세계를 연결해줍니다.
- 덕분에 Spring의 강력한 기능을 서블릿 필터에서도 사용할 수 있습니다.

---

# Spring Security 인증 아키텍처

## 1. SecurityContextHolder

- Spring Security 인증 모델의 핵심
- SecurityContext를 포함
- 현재 인증된 사용자 정보 저장 및 관리

### 사용자 인증 설정 예시

```java
 SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication = new TestingAuthenticationToken("username", "password", "ROLE_USER");
context.setAuthentication(authentication);
SecurityContextHolder.setContext(context);
```

### 현재 인증된 사용자 접근 예시

```java
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
```

## 2. SecurityContext

- SecurityContextHolder로부터 얻음
- Authentication 객체 포함

## 3. Authentication

- 두 가지 주요 역할:
    1. AuthenticationManager의 입력으로 사용
    2. 현재 인증된 사용자 표현

### 주요 구성 요소

1. principal: 사용자 식별 (보통 UserDetails 인스턴스)
2. credentials: 주로 비밀번호 (인증 후 보안을 위해 제거됨)
3. authorities: 사용자 권한 (GrantedAuthority 객체로 표현)

## 4. AuthenticationManager

- Spring Security 필터의 인증 수행 방식 정의
- 가장 흔한 구현체: ProviderManager

## 5. ProviderManager

- 여러 AuthenticationProvider 인스턴스 관리
- 각 AuthenticationProvider가 특정 인증 유형 처리

## 6. AuthenticationProvider

- 특정 인증 유형 처리 (예: 사용자명/비밀번호, JWT 등)
- 인증 성공/실패 여부 결정

## 7. AuthenticationEntryPoint

- 클라이언트에게 자격 증명 요청 시 사용
- 인증되지 않은 요청에 대한 응답 처리 (예: 로그인 페이지 리다이렉트)

## 8. AbstractAuthenticationProcessingFilter

- 사용자 자격 증명 인증을 위한 기본 필터
- 인증 과정:
    1. HttpServletRequest로부터 Authentication 객체 생성
    2. AuthenticationManager에 인증 요청
    3. 인증 성공/실패에 따른 후속 처리

### 인증 성공 시 처리

- SecurityContextHolder에 Authentication 설정
- RememberMeServices 처리
- AuthenticationSuccessHandler 호출

### 인증 실패 시 처리

- SecurityContextHolder 정리
- RememberMeServices 실패 처리
- AuthenticationFailureHandler 호출
