## **영속성 관련 메소드 비교표**

| **메소드** | **주요 기능** | **상태 변화** | **DB 영향** | **변경 감지** |
| --- | --- | --- | --- | --- |
| persist | 엔티티 등록 | 비영속 → 영속 | 커밋 시 INSERT | O |
| detach | 엔티티 분리 | 영속 → 준영속 | 없음 | X |
| merge | 엔티티 병합 | 준영속/비영속 → 영속 | 필요 시 UPDATE | O |
| remove | 엔티티 삭제 | 영속 → 삭제 | 커밋 시 DELETE | O |
| refresh | 엔티티 새로고침 | 변화 없음 | SELECT | O |
1. 영속 (Managed)
    - JPA가 엔티티를 관리하는 상태
    - 특징:
        - 변경 감지 (Dirty Checking) 대상
        - 1차 캐시에 저장됨
        - 트랜잭션 커밋 시 자동으로 DB에 반영
    - 예: entityManager.persist(entity) 호출 후
2. 준영속 (Detached)
    - 한때 영속 상태였지만 현재는 JPA 관리에서 벗어난 상태
    - 특징:
        - 식별자(ID)는 가지고 있음
        - 변경 감지 대상에서 제외
        - DB 동기화 되지 않음
    - 예: entityManager.detach(entity) 호출 후
3. 비영속 (Transient)
    - JPA와 전혀 관계없는 새로운 객체 상태
    - 특징:
        - 식별자 값 없을 수 있음
        - JPA가 관리하지 않음
        - DB와 전혀 관계 없음
    - 예: new Entity() 로 객체 생성 직후

---

1. 비영속 (New/Transient):
    - 새로 생성된 객체, JPA와 관련 없음
    - 예: **`new Member()`**
2. 영속 (Managed):
    - JPA가 관리하는 상태
    - **`entityManager.persist(entity)`** 또는 조회 후
3. 준영속 (Detached):
    - 영속 상태였다가 분리된 상태
    - **`entityManager.detach(entity)`** 또는 **`clear()`**, **`close()`** 후
4. 삭제 (Removed):
    - 삭제 예정 상태
    - **`entityManager.remove(entity)`** 호출 후

주요 전환:

- 비영속 → 영속: **`persist()`**
- 영속 → 준영속: **`detach()`**, **`clear()`**, **`close()`**
- 준영속 → 영속: **`merge()`**
- 영속 → 삭제: **`remove()`**

---

## Blog Entity 구현하기

### 1. 클래스 정의 하기

- @Entity 어노테이션으로 이 클래스가 DB Table과 매핑될 JPA Entity임을 선언
- @Table(name-”blogs”)로 실제 DB Table이름ㅇ르 지정

```java
@Entity
@Table(name = "blogs")
public class Blog {
}
```

### 2. 필드 정의 하기

- 기본적으로 각 필드는 DB 테이블 컬럼과 매핑 됨
- @Id로 기본키 지정
- @GeneratedValue(strategy = 생성전략) 을 통해 생성전략 지정 Generation.Type.IDENTITY는 DB의 AUTO-INCREAMENT와 같음
- @Column 을 통해 각 필드 특성 NOT NULL, length(varchar) 등을 지정..

```java

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 기본키 생성 전략 (AUTO-INCREAMENT)
    @Column(nullable = false)
    private Long blogId;

    @Column(nullable = false, length = 50)
    private String blogFid;

    @Column(nullable = false, unique = true)
    private boolean blogMain;

    @Column(nullable = false, length = 100)
    private String blogName;

    @Column(nullable = false, length = 100)
    private String blogMbNickname;

    @Column
    private String blogDescription;

    @Column(nullable = false)
    private Boolean blogIsPublic;

    @CreationTimestamp  // 엔티티 생성시 자동으로 현재 시간 설정
    @Column(nullable = false)
    private LocalDateTime createdAt;

    @Column
    private LocalDateTime updatedAt;

```

### 3. 생성자

- protected 기본 생성자: JPA가 엔티티를 생성할 때 사용
- private 전체 필드 생성자: 엔티티 생성 시 사용

```java
 		protected Blog(){

    }

    private Blog(Long blogId, String blogFid, boolean blogMain, String blogName, String blogMbNickname, String blogDescription, Boolean blogIsPublic, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.blogId = blogId;
        this.blogFid = blogFid;
        this.blogMain = blogMain;
        this.blogName = blogName;
        this.blogMbNickname = blogMbNickname;
        this.blogDescription = blogDescription;
        this.blogIsPublic = blogIsPublic;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
```

### 4. 정적 팩토리 메소드

```java
  public static Blog ofNewBlog(String blogFid, Boolean blogMain, String blogName, String blogMbNickname, String blogDescription){
        return new Blog(null, blogFid, blogMain, blogName, blogMbNickname, blogDescription, false, null, null);

    }
```

- 새로운 블로그 객체 생성 메소드

### 5. 생명 주기 콜백 메소드

```java
  @PrePersist  // 엔티티가 처음 저장 될 때 실행
    public void prePersistForCreatedAtAndUpdatedAt(){
        this.createdAt=null;
        this.updatedAt=null;
        // null값일시 DB에서 자동으로 현재 시간 설정
    }

    @PreUpdate // 엔티티 업데이트시 실행
    public void preUpdateForUpdatedAt(){
        this.updatedAt = LocalDateTime.now();
    }
```

### 6. update, Getter , equals, hashCode, toString ,,

```java
 public void update(String blogName, String blogMbNickname, String blogDescription, Boolean blogIsPublic){
        this.blogName = blogName;
        this.blogMbNickname = blogMbNickname;
        this.blogDescription = blogDescription;
        this.blogIsPublic = blogIsPublic;
    }
     @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Blog blog = (Blog) o;
        return blogMain == blog.blogMain && Objects.equals(blogId, blog.blogId) && Objects.equals(blogFid, blog.blogFid) && Objects.equals(blogName, blog.blogName) && Objects.equals(blogMbNickname, blog.blogMbNickname) && Objects.equals(blogDescription, blog.blogDescription) && Objects.equals(blogIsPublic, blog.blogIsPublic) && Objects.equals(createdAt, blog.createdAt) && Objects.equals(updatedAt, blog.updatedAt);
    }

    @Override
    public int hashCode() {
        return Objects.hash(blogId, blogFid, blogMain, blogName, blogMbNickname, blogDescription, blogIsPublic, createdAt, updatedAt);
    }

    @Override
    public String toString() {
        return "Blog{" +
                "blogId=" + blogId +
                ", blogFid='" + blogFid + '\'' +
                ", blogMain=" + blogMain +
                ", blogName='" + blogName + '\'' +
                ", blogMbNickname='" + blogMbNickname + '\'' +
                ", blogDescription='" + blogDescription + '\'' +
                ", blogIsPublic=" + blogIsPublic +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
    /**
     * 블로그 공개여부 설정
     * @param blogIsPublic
     */
    public void enableBlogPublicAccess(boolean blogIsPublic){
        this.blogIsPublic = blogIsPublic;
    }
    
    
    // 이외 Getter Method
```

## 테스트 코드 작성하기

```java
package com.nhnacademy.blog.bloginfo.domain;

import com.nhnacademy.blog.common.config.ApplicationConfig;

import jakarta.persistence.Entity;
import jakarta.persistence.EntityManager;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.transaction.annotation.Transactional;

/**
 * TODO#2-TEST blog entity Test 구현
 */

@ActiveProfiles("test")
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = ApplicationConfig.class)
@Transactional
class BlogTest {

    @Autowired
    EntityManager entityManager;

    @Test
    @DisplayName("blog 등록")
    void saveTest(){
        Blog blog = Blog.ofNewBlog(
                "testBlogFid",
                false,
                "testName",
                "testMbNickName",
                "testBlogDescription"
        );

        entityManager.persist(blog);
        entityManager.flush();

        Blog findBlog = entityManager.find(Blog.class, blog.getBlogId());

        Assertions.assertNotNull(blog);
        Assertions.assertEquals(blog, findBlog);
    }

    @Test
    @DisplayName("blog 수정")
    void updateTest(){
        Blog blog = Blog.ofNewBlog(
                "testBlogFid",
                false,
                "testName",
                "testMbNickName",
                "testBlogDescription"
        );

        entityManager.persist(blog);

        entityManager.flush();

        blog.update("updateName", "updateMbNicName", "updateDescription", true);

        Blog findBlog = entityManager.find(Blog.class, blog.getBlogId());
        Assertions.assertNotNull(findBlog);
        Assertions.assertEquals(blog, findBlog);

    }

    @Test
    @DisplayName("blog 삭제")
    void deleteTest(){
        Blog blog = Blog.ofNewBlog(
                "testBlogFid",
                false,
                "testName",
                "testMbNickName",
                "testBlogDescription"
        );

        entityManager.persist(blog);
        entityManager.flush();

        Long blogId = blog.getBlogId();

        entityManager.remove(blog);
        entityManager.flush();

        entityManager.clear();

        Blog deleteBlog = entityManager.find(Blog.class, blog.getBlogId());
        Assertions.assertNull(deleteBlog, "삭제된 blog는 null이어야함");

    }

}
```

---

레전드 레코드

```java
public class BlogMemberResponse {
    private final Long blogId;
    private final String blogName;
    private final Long mbNo;
    private final String mbName;

    public BlogMemberResponse(Long blogId, String blogName, Long mbNo, String mbName) {
        this.blogId = blogId;
        this.blogName = blogName;
        this.mbNo = mbNo;
        this.mbName = mbName;
    }

    public Long getBlogId() {
        return blogId;
    }

    public String getBlogName() {
        return blogName;
    }

    public Long getMbNo() {
        return mbNo;
    }

    public String getMbName() {
        return mbName;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BlogMemberResponse that = (BlogMemberResponse) o;
        return Objects.equals(blogId, that.blogId) &&
               Objects.equals(blogName, that.blogName) &&
               Objects.equals(mbNo, that.mbNo) &&
               Objects.equals(mbName, that.mbName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(blogId, blogName, mbNo, mbName);
    }

    @Override
    public String toString() {
        return "BlogMemberResponse{" +
                "blogId=" + blogId +
                ", blogName='" + blogName + '\'' +
                ", mbNo=" + mbNo +
                ", mbName='" + mbName + '\'' +
                '}';
    }
}

```

이거를 레코드를 쓴다면?

```java

package com.nhnacademy.blog.mapping;

/**
 * TODO#3 - 블로그 맴버를 조회할 때 응답 객체로 사용하기위해서 BlogMemberResponse class를 구현 합니다.
 *  - record를 사용해도 좋습니다.
 *  - getter method를 구현 합니다.
 *  - toString() method를 구현 합니다.
 *  - setter method는 구현하지 않습니다.
 */

public record BlogMemberResponse(Long blogId, String blogName, Long mbNo, String mbName) {

}
```

JAVA 14부터 기본 제공해주는 기능

<aside>
💡

# entityManager.contains()

- 1차 캐시에 존재하는지 확인
</aside>
